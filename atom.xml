<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flylmt</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-10T11:43:55.430Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>flylmt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IDE</title>
    <link href="http://example.com/posts/12a95043.html"/>
    <id>http://example.com/posts/12a95043.html</id>
    <published>2023-11-04T04:44:53.000Z</published>
    <updated>2024-10-10T11:43:55.430Z</updated>
    
    <content type="html"><![CDATA[<p>如何在IDE中存放多个main函数，只要把不需要的main函数所属文件从属性——生成中排除就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何在IDE中存放多个main函数，只要把不需要的main函数所属文件从属性——生成中排除就可以了&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>The Missing Semester</title>
    <link href="http://example.com/posts/340e4237.html"/>
    <id>http://example.com/posts/340e4237.html</id>
    <published>2023-10-01T14:34:34.000Z</published>
    <updated>2024-10-10T11:43:55.434Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>CSAPP</title>
    <link href="http://example.com/posts/a0419e9f.html"/>
    <id>http://example.com/posts/a0419e9f.html</id>
    <published>2023-09-30T13:23:38.000Z</published>
    <updated>2024-10-10T11:43:55.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>相关连接：</p><p>有个视频看：<a href="https://www.bilibili.com/video/BV1cD4y1D7uR/?vd_source=ef7c7a172527535e7a83fc2ac61994d5">【CSAPP-深入理解计算机系统】1-1.计算机系统漫游_哔哩哔哩_bilibili</a></p><ul><li><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2023/0.6.html">Getting Source Code for PAs · GitBook (nju-projectn.github.io)</a></li><li><a href="https://missing-semester-cn.github.io/">计算机教育中缺失的一课 · the missing semester of your cs education (missing-semester-cn.github.io)</a></li><li><a href="https://zhuanlan.zhihu.com/p/567862782">自制处理器系列（一）：一生一芯计划-预先学习阶段（P线） - 知乎 (zhihu.com)</a></li><li><a href="https://i.linuxtoy.org/docs/guide/index.html">开源世界旅行手册 (linuxtoy.org)</a></li><li><img src="https://nju-projectn.github.io/ics-pa-gitbook/ics2023/images/cs-hierarchy.jpg" alt="cs-hierarchy"></li></ul><h2 id="一、计算机系统"><a href="#一、计算机系统" class="headerlink" title="一、计算机系统"></a>一、计算机系统</h2><p>1、如何用好Linux</p><ol><li>卸载Windows, 解放思想, 摆脱Windows对你的阻碍. 与其默认”没办法, 也只能这样了”, 你应该去尝试”看看能不能把这件事做好”.<ul><li>Linux下也有相应的常用软件, 如Chrome, WPS, 中文输入法, mplayer…</li><li>没有Windows你也可以活下去</li><li>实在不行可以装个Windows虚拟机备用</li></ul></li><li>熟悉一些常用的命令行工具, 并强迫自己在日常操作中使用它们<ul><li>文件管理 - <code>cd</code>, <code>pwd</code>, <code>mkdir</code>, <code>rmdir</code>, <code>ls</code>, <code>cp</code>, <code>rm</code>, <code>mv</code>, <code>tar</code></li><li>文件检索 - <code>cat</code>, <code>more</code>, <code>less</code>, <code>head</code>, <code>tail</code>, <code>file</code>, <code>find</code></li><li>输入输出控制 - 重定向, 管道, <code>tee</code>, <code>xargs</code></li><li>文本处理 - <code>vim</code>, <code>grep</code>, <code>awk</code>, <code>sed</code>, <code>sort</code>, <code>wc</code>, <code>uniq</code>, <code>cut</code>, <code>tr</code></li><li>正则表达式</li><li>系统监控 - <code>jobs</code>, <code>ps</code>, <code>top</code>, <code>kill</code>, <code>free</code>, <code>dmesg</code>, <code>lsof</code></li><li>上述工具覆盖了程序员绝大部分的需求<ul><li>可以先从简单的尝试开始, 用得多就记住了, 记不住就<code>man</code></li></ul></li></ul></li><li>RTFM + STFW</li><li>坚持.<ul><li>心态上, 相信总有对的工具能帮助我做得更好</li><li>行动上, 愿意付出时间去找到它, 学它, 用它</li></ul></li></ol><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>1、tmux</p><p>Linux终端分屏工具</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;过程&quot;&gt;&lt;a href=&quot;#过程&quot; class=&quot;headerlink&quot; title=&quot;过程&quot;&gt;&lt;/a&gt;过程&lt;/h2&gt;&lt;p&gt;相关连接：&lt;/p&gt;
&lt;p&gt;有个视频看：&lt;a href=&quot;https://www.bilibili.com/video/BV1cD4y1D7u</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CUDA</title>
    <link href="http://example.com/posts/575c3f93.html"/>
    <id>http://example.com/posts/575c3f93.html</id>
    <published>2023-09-25T10:22:43.000Z</published>
    <updated>2024-10-10T11:43:55.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、向导"><a href="#一、向导" class="headerlink" title="一、向导"></a>一、向导</h2><p>1、推荐书籍：</p><ul><li><p>CUDA C编程权威指南 John Cheng</p></li><li><p>CUDA并行程序射击：GPU编程 Shane Cook</p></li><li><p>CUDA高性能并行计算 Duane Storti</p></li></ul><p>2、学习顺序：</p><p>关于入门CUDA，我是先看的《CUDA并行编程指南》就是大家说的绿皮书；<br>有了初步概念后结合NVIDA官方的Ducumation（<a href="https://docs.nvidia.com/cuda/index.html%EF%BC%89%E7%9C%8B%E8%87%AA%E5%B7%B1%E9%81%87%E5%88%B0%E7%9A%84%E9%99%8C%E7%94%9F%E6%A6%82%E5%BF%B5%EF%BC%9B">https://docs.nvidia.com/cuda/index.html）看自己遇到的陌生概念；</a><br>之后编了些CSDN上大家都在说的Reduce、Scan什么的基础算法；<br>然后下载了CUDA C Programming Guide（<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html%EF%BC%89%EF%BC%8C%E4%BB%94%E7%BB%86%E7%9C%8B%E4%BA%86%E4%B8%80%E9%81%8D%EF%BC%8C%E6%83%B3%E6%83%B3%E4%B9%8B%E5%89%8D%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%95%88%E7%8E%87%E5%A6%82%E4%BD%95%EF%BC%8C%E5%86%8D%E6%94%B9%E8%BF%9B%EF%BC%9B">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html），仔细看了一遍，想想之前写的程序效率如何，再改进；</a></p><p>3、入门教程：</p><p>❝ 最近因为项目需要，入坑了CUDA，又要开始写很久没碰的C++了。对于CUDA编程以及它所需要的GPU、计算机组成、操作系统等基础知识，我基本上都忘光了，因此也翻了不少教程。这里简单整理一下，给同样有入门需求的同学们参考一下。<br>❞</p><p>官方文档及书籍</p><p>英文好、时间充裕的同学可以精读官方文档或者著作。</p><p>NVIDIA CUDA C++ Programming Guide</p><p>「地址：」 <a href="https://link.zhihu.com/?target=https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html">https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html</a></p><p>这是英伟达官方的CUDA编程教程，但是我英文一般，简单过了一遍之后感觉很多细节没讲，有一定的跳跃性，所以我看完还是很朦胧。</p><p>CUDA C++ Best Practices Guide</p><p>「地址：」 <a href="https://link.zhihu.com/?target=https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html">https://docs.nvidia.com/cuda/cuda-c-best-practices-guide/index.html</a></p><p>这也是英伟达官方的CUDA编程教程，不过侧重点在实践方面，比如如何编程才能最大化利用GPU特性提升性能，建议基础打好之后再来看这个。</p><p>CUDA C编程权威指南</p><p>这么经典的书就不用我多说了，英文原版叫《Professional CUDA C Programming》</p><p>个人博客</p><p>像我这种英文差、想快速入门的只能找找中文博客看看了，还是找到不少非常奈斯的教程的。</p><p>谭升的博客（强推！！！）</p><p>「地址：」 <a href="https://link.zhihu.com/?target=https://face2ai.com/program-blog/%23GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89">https://face2ai.com/program-blog/#GPU编程（CUDA）</a></p><p>这是我最近发现的又一个宝藏博主，看完他的GPU编程系列教程后感觉豁然开朗，很多底层的原理和细节都通彻了，「强烈安利！」</p><p>他在github还开源了教程对应的示例代码： <a href="https://link.zhihu.com/?target=https://github.com/Tony-Tan/CUDA_Freshman">https://github.com/Tony-Tan/CUDA_Freshman</a></p><p>CUDA编程入门极简教程</p><p>「地址：」 <a href="https://zhuanlan.zhihu.com/p/34587739">https://zhuanlan.zhihu.com/p/34587739</a></p><p>速览即可，看完就会写最简单的CUDA代码了。</p><p>CUDA编程入门系列</p><p>「地址：」 <a href="https://zhuanlan.zhihu.com/p/97044592">https://zhuanlan.zhihu.com/p/97044592</a></p><p>这位大佬写了六篇，主要是通过一个简单的加法的例子，一步步讲了CUDA优化的若干种方法，拿来上手实践一下还是很棒的。</p><p>CUDA编程系列</p><p>「地址：」 <a href="https://link.zhihu.com/?target=https://blog.csdn.net/sunmc1204953974/article/details/51000970">https://blog.csdn.net/sunmc1204953974/article/details/51000970</a></p><p>这个系列写的也是很全了，十几篇，建议快速通读一下。</p><p>开源代码</p><p>有很多的CUDA源码可以供我们慢慢学习，我这就简单给几个典型的Transformer系列的加速代码了。</p><p>LightSeq</p><p>「地址：」 <a href="https://link.zhihu.com/?target=https://github.com/bytedance/lightseq">https://github.com/bytedance/lightseq</a></p><p>这是字节跳动开源的生成模型推理加速引擎，BERT、GPT、VAE等等全都支持，速度也是目前业界最快的之一。</p><p>FasterTransformer</p><p>「地址：」 <a href="https://link.zhihu.com/?target=https://github.com/NVIDIA/DeepLearningExamples/tree/master/FasterTransformer">https://github.com/NVIDIA/DeepLearningExamples/tree/master/FasterTransformer</a></p><p>这是英伟达开源的Transformer推理加速引擎。</p><p>TurboTransformers</p><p>「地址：」 <a href="https://link.zhihu.com/?target=https://github.com/Tencent/TurboTransformers">https://github.com/Tencent/TurboTransformers</a></p><p>这是腾讯开源的Transformer推理加速引擎。</p><p>DeepSpeed</p><p>「地址：」 <a href="https://link.zhihu.com/?target=https://github.com/microsoft/DeepSpeed">https://github.com/microsoft/DeepSpeed</a></p><p>这是微软开源的深度学习分布式训练加速引擎。</p><p>❝ 我mentor说，不需要看这些，然后甩给了我20行代码，说看懂了就行了。结果我看懂了，门还是没开QAQ，所以建议还是看看底层一些的原理，加深自己的理解，特别是我强推的那篇博客。<br>❞</p><p>4、安装CUDA</p><p><img src="E:\Blog\source_posts\CUDA\image-20230925190808357.png" alt="image-20230925190808357"></p><h2 id="二、正式学习"><a href="#二、正式学习" class="headerlink" title="二、正式学习"></a>二、正式学习</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、向导&quot;&gt;&lt;a href=&quot;#一、向导&quot; class=&quot;headerlink&quot; title=&quot;一、向导&quot;&gt;&lt;/a&gt;一、向导&lt;/h2&gt;&lt;p&gt;1、推荐书籍：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CUDA C编程权威指南 John Cheng&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C&amp;C++</title>
    <link href="http://example.com/posts/f43812d6.html"/>
    <id>http://example.com/posts/f43812d6.html</id>
    <published>2023-09-20T11:33:19.000Z</published>
    <updated>2024-10-10T11:43:55.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><h2 id="一、C语言基础"><a href="#一、C语言基础" class="headerlink" title="一、C语言基础"></a>一、C语言基础</h2><p>首先看下面一个例子——例1.1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;a,&amp;b)</span><br><span class="line">    c = max(a,b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;max = %d\n&quot;</span>,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求两数最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;y)z=x;</span><br><span class="line">    <span class="keyword">else</span> z=y;</span><br><span class="line">    <span class="keyword">return</span>(z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、-include"><a href="#1、-include" class="headerlink" title="1、#include &lt;stdio.h&gt;"></a>1、#include &lt;stdio.h&gt;</h3><p>这里可以分为两部分分析：</p><p>#include是编译预处理指令</p><p>stdio.h是一个头文件（hearder file)，stdio就是standard input &amp; output的缩写，相关信息就是先放在了此头文件内，头文件定义了三个变量类型、一些宏和各种函数来执行输入和输出。</p><p>总的来看这是用于为编译系统提供函数库中输入输出函数的相关信息</p><h3 id="2、return-0；"><a href="#2、return-0；" class="headerlink" title="2、return 0；"></a>2、return 0；</h3><p>​C99建议把main函数指定类型为int，返回值为整数，所以当主函数正常执行完毕，得到的函数值就是0，但出现异常就会返回非0的数（1或者-1），这个返回值是返回给调用main函数的操作系统的，程序员可以利用操作指令检查main函数的返回值从而判断main函数是否正常执行，如果不写有的编译系统会自动加上，为了规范和可移植性，建议将main函数设为int型，并在函数末尾加上”return 0；”</p><h3 id="3、C程序的结构"><a href="#3、C程序的结构" class="headerlink" title="3、C程序的结构"></a>3、C程序的结构</h3><p>根据例1.1可以得出c程序结构有以下特点</p><ol><li><p>一个源文件可以包含三个部分：</p><ul><li><p>预处理指令：在编译器对源程序编译之前现有一个预编译器对预处理指令进行预处理，得到的结果取代#include &lt;stdio.h&gt;与其他部分一起组成一个可以编译的最后的源程序，当然&lt;&gt;间还有其他标准库函数</p></li><li><p>全局声明</p></li><li><p>函数定义</p></li></ul></li><li><p>函数时C程序的主要组成部分</p></li><li><p>函数包含两个部分：</p><ul><li>函数首部：函数类型、函数名、函数属性、函数参数、参数类型</li><li>函数体{}：声明部分、执行部分</li></ul></li><li><p>程序总是从main函数开始的，与其位置无关</p></li></ol><h3 id="4、C程序的运行"><a href="#4、C程序的运行" class="headerlink" title="4、C程序的运行"></a>4、C程序的运行</h3><p>1、源程序的编写</p><p>2、编译：预编译和正式编译，此步骤也进行了语法错误检查</p><p>3、连接：将所有编译得到的目标模块连接装配，再与函数库连接形成一个整体，生成一个可供计算机执行的目标程序</p><h3 id="5、程序设计的任务"><a href="#5、程序设计的任务" class="headerlink" title="5、程序设计的任务"></a>5、程序设计的任务</h3><p>1、问题分析——设计算法——编写程序——编译连接——运行程序，分析结果——编写程序文档</p><p>2、这些任务对应实际开发中的职位是什么呢？</p><h3 id="6、原码反码补码"><a href="#6、原码反码补码" class="headerlink" title="6、原码反码补码"></a>6、原码反码补码</h3><ul><li><p>计算机只能识别0和1, 所以计算机中存储的数据都是以0和1的形式存储的</p></li><li><p>数据在计算机内部是以补码的形式储存的, 所有数据的运算都是以补码进行的</p></li><li><p>正数的原码、反码和补码</p><ul><li><p>正数的原码、反码和补码都是它的二进制</p></li><li><p>例如: 12的原码、反码和补码分别为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>负数的原码、反码和补码</p><ul><li>二进制的最高位我们称之为符号位, 最高位是0代表是一个正数, 最高位是1代表是一个负数</li><li>一个负数的原码, 是将该负数的二进制最高位变为1</li><li>一个负数的反码, 是将该数的原码<code>除了符号位</code>以外的其它位取反</li><li>一个负数的补码, 就是它的反码 + 1</li><li>例如: -12的原码、反码和补码分别为</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span> <span class="comment">// 12二进制</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span> <span class="comment">// -12原码</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>  <span class="comment">// -12反码</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0100</span> <span class="comment">// -12补码</span></span><br></pre></td></tr></table></figure></li><li><p>负数的原码、反码和补码逆向转换</p><ul><li>反码 &#x3D; 补码-1</li><li>原码&#x3D; 反码最高位不变, 其它位取反</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0100</span> <span class="comment">// -12补码</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">0011</span>  <span class="comment">// -12反码</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1100</span> <span class="comment">// -12原码</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>为什么要引入反码和补码</p><ul><li><p>在学习本节内容之前,大家必须明白一个东西, 就是计算机只能做加法运算, 不能做减法和乘除法, 所以的减法和乘除法内部都是用加法来实现的</p><ul><li>例如: 1 - 1, 内部其实就是 1 + (-1);</li><li>例如: 3 * 3, 内部其实就是 3 + 3 + 3;</li><li>例如: 9 &#x2F; 3, 内部其实就是 9 + (-3) + (-3) + (-3);</li></ul></li><li><p>首先我们先来观察一下,如果只有原码会存储什么问题</p><ul><li>很明显, 通过我们的观察, 如果只有原码, 1-1的结果不对</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 + 1</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1原码</span></span><br><span class="line">+<span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1原码</span></span><br><span class="line"> ---------------------------------------</span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span>  == <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 1 - 1; 1 + (-1);</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1原码</span></span><br><span class="line">+<span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// -1原码</span></span><br><span class="line"> ---------------------------------------</span><br><span class="line"> <span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0010</span> == <span class="number">-2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>正是因为对于减法来说,如果使用原码结果是不正确的, 所以才引入了反码</p><ul><li>通过反码计算减法的结果, 得到的也是一个反码;</li><li>将计算的结果符号位不变其余位取反,就得到了计算结果的原码</li><li>通过对原码的转换, 很明显我们计算的结果是-0, 符合我们的预期</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 - 1; 1 + (-1);</span></span><br><span class="line"><span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1反码</span></span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1110</span>   <span class="comment">// -1反码</span></span><br><span class="line">---------------------------------------</span><br><span class="line"><span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="comment">// 计算结果反码</span></span><br><span class="line"><span class="number">1000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="comment">// 计算结果原码 == -0</span></span><br></pre></td></tr></table></figure></li><li><p>虽然反码能够满足我们的需求, 但是对于0来说, 前面的负号没有任何意义, 所以才引入了补码</p><ul><li>由于int只能存储4个字节, 也就是32位数据, 而计算的结果又33位, 所以最高位溢出了,符号位变成了0, 所以最终得到的结果是0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 1 - 1; 1 + (-1);</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="comment">// 1补码</span></span><br><span class="line"> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="number">1111</span> <span class="comment">// -1补码</span></span><br><span class="line"> ---------------------------------------</span><br><span class="line"><span class="number">10000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="comment">//计算结果补码</span></span><br><span class="line"> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="comment">//  == 0</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7、宏与宏定义"><a href="#7、宏与宏定义" class="headerlink" title="7、宏与宏定义"></a>7、宏与宏定义</h3><p>简单来说：宏定义又称为宏代换、宏替换，简称“宏”。是C提供的三种预处理功能的其中一种。</p><p>复杂的请看下面，讲的很全。下面的带参宏定义，多行宏定义，在Linux内核源码中很多。另外sizeof也是一个宏定义。</p><p>宏定义</p><p>宏定义是C提供的三种预处理功能的其中一种，这三种预处理包括：宏定义、文件包含、条件编译</p><ol><li>不带参数的宏定义：</li></ol><p>宏定义又称为宏代换、宏替换，简称“宏”。</p><p>格式： #define 标识符 字符串</p><p>其中的标识符就是所谓的符号常量，也称为“宏名”。</p><p>预处理（预编译）工作也叫做宏展开：将宏名替换为字符串。</p><p>掌握”宏”概念的关键是“换”。一切以换为前提、做任何事情之前先要换，准确理解之前就要“换”。</p><p>即在对相关命令或语句的含义和功能作具体分析之前就要换：</p><p>例： 　　#define PI 3.1415926 　　把程序中出现的PI全部换成3.1415926</p><p>说明：</p><p>（1）宏名一般用大写</p><p>（2）使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义</p><p>（3）预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，预处理不做语法检查。</p><p>（4）宏定义末尾不加分号；</p><p>（5）宏定义写在函数的花括号外边，作用域为其后的程序，通常在文件的最开头。</p><p>（6）可以用#undef命令终止宏定义的作用域</p><p>（7）宏定义可以嵌套</p><p>（8）字符串” “中永远不包含宏</p><p>（9）宏定义不分配内存，变量定义分配内存。</p><ol start="2"><li>带参数的宏定义：</li></ol><p>除了一般的字符串替换，还要做参数代换</p><p>格式： 　　#define 宏名（参数表） 字符串</p><p>例如：#define S（a,b） a*b</p><p>area&#x3D;S（3,2）；第一步被换为area&#x3D;a<em>b; ，第二步被换为area&#x3D;3</em>2;</p><p>类似于函数调用，有一个哑实结合的过程：</p><p>（1）实参如果是表达式容易出问题</p><p>#define S（r） r*r</p><p>area&#x3D;S（a+b）；第一步换为area&#x3D;r<em>r;,第二步被换为area&#x3D;a+b</em>a+b;</p><p>正确的宏定义是#define S（r） （（r）*（r））</p><p>（2）宏名和参数的括号间不能有空格</p><p>（3）宏替换只作替换，不做计算，不做表达式求解</p><p>（4）函数调用在编译后程序运行时进行，并且分配内存。宏替换在编译前进行，不分配内存</p><p>（5）宏的哑实结合不存在类型，也没有类型转换。</p><p>（6）函数只有一个返回值，利用宏则可以设法得到多个值</p><p>（7）宏展开使源程序变长，函数调用不会</p><p>（8）宏展开不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）</p><p>\3. 宏定义其他冷门、重点知识</p><p>#define用法</p><p>1、 用无参宏定义一个简单的常量</p><p>#define LEN 12</p><p>这个是最常见的用法，但也会出错。</p><p>比如下面几个知识点你会吗？可以看下：</p><p>（1） #define NAME “zhangyuncong”</p><p>程序中有”NAME”则，它会不会被替换呢？</p><p>（2） #define 0x abcd</p><p>可以吗？也就是说，可不可以用把标识符的字母替换成别的东西？</p><p>（3） #define NAME “zhang</p><p>这个可以吗？</p><p>（4） #define NAME “zhangyuncong”</p><p>程序中有上面的宏定义，并且，程序里有句：</p><p>NAMELIST这样，会不会被替换成”zhangyuncong”LIST</p><p>四个题答案都是否定的。</p><p>第一个，””内的东西不会被宏替换。这一点应该大都知道。</p><p>第二个，宏定义前面的那个必须是合法的用户标识符</p><p>第三个，宏定义也不是说后面东西随便写，不能把字符串的两个””拆开。</p><p>第四个：只替换标识符，不替换别的东西。NAMELIST整体是个标识符，而没有NAME标识符，所以不替换。</p><p>也就是说，这种情况下记住：#define 第一位置第二位置</p><p>（1） 不替换程序中字符串里的东西。</p><p>（2） 第一位置只能是合法的标识符（可以是关键字）</p><p>（3） 第二位置如果有字符串，必须把””配对。</p><p>（4） 只替换与第一位置完全相同的标识符</p><p>还有就是老生常谈的话：记住这是简单的替换而已，不要在中间计算结果，一定要替换出表达式之后再算。</p><p>2、 带参宏一般用法</p><p>比如#define MAX（a,b） （（a）&gt;（b）？（a）：（b））</p><p>则遇到MAX（1+2,value）则会把它替换成：</p><p>（（1+2）&gt;（value）？（1+2）：（value））</p><p>注意事项和无参宏差不多。</p><p>但还是应注意</p><p>#define FUN（a） “a”</p><p>则，输入FUN（345）会被替换成什么？</p><p>其实，如果这么写，无论宏的实参是什么，都不会影响其被替换成”a”的命运。</p><p>也就是说，””内的字符不被当成形参，即使它和一模一样。</p><p>那么，你会问了，我要是想让这里输入FUN（345）它就替换成”345”该怎么实现呢？</p><p>请看下面关于#的用法</p><p>3、 有参宏定义中#的用法</p><p>#define STR（str） #str</p><p>#用于把宏定义中的参数两端加上字符串的””</p><p>比如，这里STR（my#name）会被替换成”my#name”</p><p>一般由任意字符都可以做形参，但以下情况会出错：</p><p>STR（））这样，编译器不会把“）”当成STR（）的参数。</p><p>STR（，）同上，编译器不会把“，”当成STR的参数。</p><p>STR（A,B）如果实参过多，则编译器会把多余的参数舍去。（VC++2008为例）</p><p>STR（（A,B））会被解读为实参为：（A,B），而不是被解读为两个实参，第一个是（A第二个是B）。 　　 4、 有参宏定义中##的用法</p><p>#define WIDE（str） L##str</p><p>则会将形参str的前面加上L</p><p>比如：WIDE（”abc”）就会被替换成L”abc”</p><p>如果有#define FUN（a,b） vo##a##b（）</p><p>那么FUN（id ma,in）会被替换成void main（）</p><p>5、 多行宏定义：</p><p>#define doit（m,n） for（int i&#x3D;0;i&lt;（n）；++i）\</p><p>{\</p><p>m+&#x3D;i;\</p><p>}</p><h3 id="、练习题"><a href="#、练习题" class="headerlink" title="、练习题"></a>、练习题</h3><p>1、返回三数最大值</p><p>2、简单图形输出题目</p><h2 id="二、算法：程序的灵魂"><a href="#二、算法：程序的灵魂" class="headerlink" title="二、算法：程序的灵魂"></a>二、算法：程序的灵魂</h2><h3 id="1、"><a href="#1、" class="headerlink" title="1、"></a>1、</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C&quot;&gt;&lt;a href=&quot;#C&quot; class=&quot;headerlink&quot; title=&quot;C&quot;&gt;&lt;/a&gt;C&lt;/h1&gt;&lt;h2 id=&quot;一、C语言基础&quot;&gt;&lt;a href=&quot;#一、C语言基础&quot; class=&quot;headerlink&quot; title=&quot;一、C语言基础&quot;&gt;&lt;/a&gt;一、</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>软件设计师</title>
    <link href="http://example.com/posts/e5eb39ed.html"/>
    <id>http://example.com/posts/e5eb39ed.html</id>
    <published>2023-09-19T11:31:54.000Z</published>
    <updated>2024-10-10T11:43:55.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-计算机系统知识"><a href="#第一章-计算机系统知识" class="headerlink" title="第一章 计算机系统知识"></a>第一章 计算机系统知识</h1><h2 id="1-1-计算机基础知识"><a href="#1-1-计算机基础知识" class="headerlink" title="1.1 计算机基础知识"></a>1.1 计算机基础知识</h2><h3 id="1-1-1计算机系统硬件基本组成"><a href="#1-1-1计算机系统硬件基本组成" class="headerlink" title="1.1.1计算机系统硬件基本组成"></a>1.1.1计算机系统硬件基本组成</h3><p>CPU：运算器</p><p>​           控制器</p><p>存储器：内存、外存</p><p>外设：输入设备</p><p>​           输出设备</p><h3 id="1-1-2中央处理单元"><a href="#1-1-2中央处理单元" class="headerlink" title="1.1.2中央处理单元"></a>1.1.2中央处理单元</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-计算机系统知识&quot;&gt;&lt;a href=&quot;#第一章-计算机系统知识&quot; class=&quot;headerlink&quot; title=&quot;第一章 计算机系统知识&quot;&gt;&lt;/a&gt;第一章 计算机系统知识&lt;/h1&gt;&lt;h2 id=&quot;1-1-计算机基础知识&quot;&gt;&lt;a href=&quot;#1-1-计算</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>杂七杂八</title>
    <link href="http://example.com/posts/f13b8939.html"/>
    <id>http://example.com/posts/f13b8939.html</id>
    <published>2023-09-14T15:56:41.000Z</published>
    <updated>2024-10-10T11:43:55.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译-解释-脚本"><a href="#编译-解释-脚本" class="headerlink" title="编译&amp;解释&amp;脚本"></a>编译&amp;解释&amp;脚本</h1><p>编译型语言在程序执行之前，有一个单独的编译过程，将程序翻译成机器语言就不用再进行翻译了。</p><p>解释型语言，是在运行的时候将程序翻译成机器语言，所以运行速度相对于编C&#x2F;C++ 等都是编译型语言，而Java，C#等都是解释型语言。</p><p>虽然Java程序在运行之前也有一个编译过程，但是并不是将程序编译成机器语言，而是将它编译成字节码（可以理解为一个中间语言）。<br>在运行的时候，由JVM将字节码再翻译成机器语言。<br>注：脚本语言一般都有相应的脚本引擎来解释执行。 他们一般需要解释器才能运行。JAVASCRIPT,ASP,PHP,PERL,Nuva都是脚本语言。C&#x2F;C++编译、链接后，可形成独立执行的exe文件。</p><h3 id="编译型语言："><a href="#编译型语言：" class="headerlink" title="编译型语言："></a>编译型语言：</h3><ol><li>编译型语言最大的优势之一就是其执行速度。用C&#x2F;C++编写的程序运行速度要比用Java编写的相同程序快30%-70%。</li><li>编译型程序比解释型程序消耗的内存更少。</li><li>不利的一面——编译器比解释器要难写得多。</li><li>编译器在调试程序时提供不了多少帮助——有多少次在你的C语言代码中遇到一个“空指针异常”时，需要花费好几个小时来明确错误到底在代码中的什么位置。</li><li>可执行的编译型代码要比相同的解释型代码大许多。例如，C&#x2F;C++的.exe文件要比同样功能的Java的.class文件大很多。</li><li>编译型程序是面向特定平台的因而是平台依赖的。</li><li>编译型程序不支持代码中实现安全性——例如，一个编译型的程序可以访问内存的任何区域，并且可以对你的PC做它想做的任何事情（大部分病毒是使用编译型语言编写的）</li><li>由于松散的安全性和平台依赖性，编译型语言不太适合开发因特网或者基于Web的应用。</li></ol><h3 id="解释型语言："><a href="#解释型语言：" class="headerlink" title="解释型语言："></a>解释型语言：</h3><ol><li>解释型语言提供了极佳的调试支持。一名Java程序员只需要几分钟就可以定位并修复一个“空指针异常”，因为Java运行环境不仅指明了异常的性质，而且给出了异常发生位置具体的行号和函数调用顺序（著名的堆栈跟踪信息）。这样的便利是编译型语言所无法提供的。</li><li>另一个优势是解释器比编译器容易实现</li><li>解释型语言最大的优势之一是其平台独立性</li><li>解释型语言也可以保证高度的安全性——这是互联网应用迫切需要的</li><li>中间语言代码的大小比编译型可执行代码小很多</li><li>平台独立性，以及严密的安全性是使解释型语言成为适合互联网和Web应用的理想语言的2个最重要的因素。</li><li>解释型语言存在一些严重的缺点。解释型应用占用更多的内存和CPU资源。这是由于，为了运行解释型语言编写的程序，相关的解释器必须首先运行。解释器是复杂的，智能的，大量消耗资源的程序并且它们会占用很多CPU周期和内存。</li><li>由于解释型应用的decode-fetch-execute（解码-抓取-执行）的周期，它们比编译型程序慢很多。</li><li>解释器也会做很多代码优化，运行时安全性检查；这些额外的步骤占用了更多的资源并进一步降低了应用的运行速度。</li></ol><h3 id="脚本语言："><a href="#脚本语言：" class="headerlink" title="脚本语言："></a>脚本语言：</h3><p>又被称为扩建的语言，或者动态语言，是一种编程语言，用来控制软件应用程序，脚本通常以文本（如<a href="https://baike.baidu.com/item/ASCII?fromModule=lemma_inlink">ASCII</a>）保存，只在被调用时进行解释或编译。脚本语言不需要编译，可以直接用，由解释器来负责解释</p><p>脚本语言的主要特征是：程序代码即是脚本程序，亦是最终<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6?fromModule=lemma_inlink">可执行文件</a>。脚本语言可分为<a href="https://baike.baidu.com/item/%E7%8B%AC%E7%AB%8B%E5%9E%8B?fromModule=lemma_inlink">独立型</a>和<a href="https://baike.baidu.com/item/%E5%B5%8C%E5%85%A5?fromModule=lemma_inlink">嵌入</a>型，独立型脚本语言在其执行时完全依赖于解释器，而嵌入型脚本语言通常在编程语言中（如<a href="https://baike.baidu.com/item/C?fromModule=lemma_inlink">C</a>、<a href="https://baike.baidu.com/item/C%2B%2B?fromModule=lemma_inlink">C++</a>、<a href="https://baike.baidu.com/item/VB/6044?fromModule=lemma_inlink">VB</a>、<a href="https://baike.baidu.com/item/Java/85979?fromModule=lemma_inlink">Java</a>等）被嵌入使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编译-解释-脚本&quot;&gt;&lt;a href=&quot;#编译-解释-脚本&quot; class=&quot;headerlink&quot; title=&quot;编译&amp;amp;解释&amp;amp;脚本&quot;&gt;&lt;/a&gt;编译&amp;amp;解释&amp;amp;脚本&lt;/h1&gt;&lt;p&gt;编译型语言在程序执行之前，有一个单独的编译过程，将程序翻译成</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>磁力链接与下载</title>
    <link href="http://example.com/posts/3295c0ff.html"/>
    <id>http://example.com/posts/3295c0ff.html</id>
    <published>2023-09-14T12:28:30.000Z</published>
    <updated>2024-10-10T11:43:55.438Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eMule"><a href="#eMule" class="headerlink" title="eMule"></a>eMule</h1><h2 id="网络指南"><a href="#网络指南" class="headerlink" title="网络指南"></a><strong>网络指南</strong></h2><p>从0.42.1版开始，eMule（电骡）就具有了两个不同特征的网络——传统的基于服务器的eD2K网络（eDonkey2000 Network - 电驴网络）和一个基于Kademlia的全新的无服务器拓扑结构网络。<br>本质上两个网络的作用一致。它们两者都分别提供一种寻找其他用户及你想下载的文件的方法。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>文件识别<br>所有文件都有一个Hash——哈希值（指纹）。Hash是独一无二地标识文件的字母和数字。一个文件的文件名可能千变万化，但文件的Hash却不会因此改变。因而不管其他用户给这个文件起了什么名字，每个用户都可以找到这个文件的来源。<br>另外，文件会被分割成 9.28 兆大小的文件片段。每个片段都有Hash标识。举例来说，一个600兆的文件会被分成65个片段，接着每个片段会被标上Hash。然后文件的Hash就根据这些文件片段的Hash被计算出来，并用在网络中作为文件标识。</p><p>其他客户端的识别<br>正如文件Hash一样，每一个网络中的用户都有一个永久性的Hash。这种用户识别依靠一个公钥&#x2F;私钥交握机制的强力保障以防止滥用。</p><p>数据下载<br>应当要理解的是 eMule实际的下载与两个网络的选择无关。两个网络的拓扑结构只与文件搜索以及为文件寻找来源客户端有关。<br>在找到来源之后，你的客户端就会连接上它。来源客户端会将该下载任务排到等候队列中。在过了一段等候时间后排到了队列第一位时，就轮到你来接收它的数据了。</p><h3 id="传统的基于服务器的eD2k"><a href="#传统的基于服务器的eD2k" class="headerlink" title="传统的基于服务器的eD2k"></a>传统的基于服务器的eD2k</h3><p>与网络的连接<br>eD2k网络的核心是eD2k服务器。要连上该网络的客户端须先连接到一个服务器。<br>当你的客户端连接到服务器的时候，服务器会检查别的客户端是否能不受限制地连接到你的客户端。如果能，服务器就会给你的客户端指派一个所谓的High ID（高ID）。如果通信受到阻碍，服务器就会给你指派一个Low ID（低ID）。<br>收到指派的ID后，eMule会将共享文件的列表发给服务器。服务器会将这列表里的文件名与Hash记录到它的数据库。</p><p>文件搜索<br>连接到网络后，客户端就可以按文件名关键字搜索文件。搜索可以是本地的或是全局的。对于本地搜索（只在你连接到的服务器中搜索），其搜索速度快但结果较少。对于全局搜索（在网络上所有的服务器中搜索），其所花时间较长但结果更多。搜索时，每个的服务器都在它的本地数据库中查找并返回任何包含关键字的文件名（与Hash）。</p><p>搜索文件来源<br>添加下载任务可以通过 eMule的搜索功能或是很多网站提供上的eD2k链接。<br>一旦任务添加到下载列表，eMule先向本地（连接到的）服务器后向所有网络上其他的服务器查寻该下载任务的来源。每个服务器会在它的数据库中寻找该文件的 Hash并返回数据库中拥有该文件的客户端。<br>文件来源是其他至少拥有相同Hash的文件的一个片段（9.28兆）的那些客户端。</p><h3 id="无服务器的Kademlia网络"><a href="#无服务器的Kademlia网络" class="headerlink" title="无服务器的Kademlia网络"></a>无服务器的Kademlia网络</h3><p>与网络的连接<br>连接到这个网络只需要任何一个已经连接到这个网络的eMule客户端的IP地址和相应端口。这被称作【引导程序】。<br>一旦一个客户端连接到了网络，这个客户端就会请求其他客户端判断自己是否能不受限制地被连接上。这个过程与服务器判断 HighID&#x2F;LowID 很相似。若连接不受限制，你就被会指派一个ID（类似于HighID）并标为<em>开放</em>状态。若连接收阻碍，你就被标为<em>通过防火墙</em>状态。从v.44a 版本开始，Kademlia网络为通过防火墙状态的用户提供了 <em>Buddy（搭档）</em>功能。Buddies（搭档）是其他拥有<em>开放</em>状态的Kademlia客户端。他们为那些通过防火墙状态的用户担任中继站，并帮着处理那些通过防火墙状态的用户所无法处理的连接。</p><p>Kademlia上的文件搜索<br>在这个网络里不论你搜索什么方法都-样。搜索文件名、下载来源或是其他用户的过程是一样的。<br>网络中没有服务器记录各个客户端和它们共享的文件-本质上，每一个客户端都又是一个小服务器。<br>由于每个客户端都由独一无二的Hash，Kademlia的理念是依靠Hash赋予客户端一些“责任”。每个Kademlia网络中的客户端都成为提供某些关键词和来源的服务器。客户端的Hash决定了它所提供的关键词和来源。<br>因此，每种搜索的目标就是找到对当前搜索主题负有责任的客户端。这个过程依赖于通过询问其他客户端获得通往目标客户端的最短路径，以此来推出自己与目标客户端的大致距离的复杂计算。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两个网络用完全不同的理念来做相同的事:搜索文件和寻找来源。Kademlia网络的主要目标是独立于服务器并提高可扩容性。服务器只能处理有限数量的用户，而且大型服务器会拖累网络。<br>Kademlia有自组织性，并且它可以依照用户数量和其连接质量来自我调整。因此，它更能防止大型网络中的传输损失。</p><h1 id="迅雷链接"><a href="#迅雷链接" class="headerlink" title="迅雷链接"></a>迅雷链接</h1><p>只是对其他格式的链接做了下 <strong>Base64</strong> 加密。</p><p>你去找个 <code>thunder://xxxx</code> 链接，把后面的 <code>xxxx</code> 复制出来。</p><p>然后网上找个 <strong>Base64 加解密</strong>的网站，把 <code>xxxx</code> 解密后你会得到一个 <code>AAyyyyZZ</code> 文本，去掉开头的 <code>AA</code> 和结尾的 <code>ZZ</code>，得到的就是真实下载链接 <code>yyyy</code>。</p><p>这个真实下载链接可以是 <strong>HTTP下载链接、BT种子文件下载链接(也算HTTP)、磁力链接。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;eMule&quot;&gt;&lt;a href=&quot;#eMule&quot; class=&quot;headerlink&quot; title=&quot;eMule&quot;&gt;&lt;/a&gt;eMule&lt;/h1&gt;&lt;h2 id=&quot;网络指南&quot;&gt;&lt;a href=&quot;#网络指南&quot; class=&quot;headerlink&quot; title=&quot;网络指南&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>java</title>
    <link href="http://example.com/posts/7f1ae6d2.html"/>
    <id>http://example.com/posts/7f1ae6d2.html</id>
    <published>2023-09-08T09:08:35.000Z</published>
    <updated>2024-10-10T11:54:11.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Java介绍"><a href="#一、Java介绍" class="headerlink" title="一、Java介绍"></a>一、Java介绍</h2><p>OpenJDK</p><p>JVM</p><p>Java优点</p><p>Java缺点</p><h2 id="二、Java基础"><a href="#二、Java基础" class="headerlink" title="二、Java基础"></a>二、Java基础</h2><h3 id="基本结构："><a href="#基本结构：" class="headerlink" title="基本结构："></a>基本结构：</h3><p>1、类</p><p>类名要求：</p><ul><li>类名必须以英文字母开头，后接字母，数字和下划线的组合</li><li>习惯以大写字母开头</li></ul><p>要注意遵守命名习惯，好的类命名：</p><ul><li>Hello</li><li>NoteBook</li><li>VRPlayer</li></ul><p>2、方法</p><p>Java入口程序规定的方法必须是静态方法，方法名必须为<code>main</code>，括号内的参数必须是String数组。</p><p>方法名也有命名规则，命名和<code>class</code>一样，但是首字母小写：</p><p>好的方法命名：</p><ul><li>main</li><li>goodMorning</li><li>playVR</li></ul><p>3、注释</p><p>Java有3种注释，第一种是单行注释，以双斜线开头，直到这一行的结尾结束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 这是注释...</span><br></pre></td></tr></table></figure><p>而多行注释以<code>/*</code>星号开头，以<code>*/</code>结束，可以有多行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">这是注释</span><br><span class="line">这也是注释</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>还有一种特殊的多行注释，以<code>/**</code>开头，以<code>*/</code>结束，如果有多行，每行通常以星号开头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@auther</span> </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这种特殊的多行注释需要写在类和方法的定义处，javadoc会提取这些文档，经过处理可以生成这个类的在线文档，文档注释中可以包含HTML标签和javadoc能理解的其他句法。</p><h3 id="变量与数据类型："><a href="#变量与数据类型：" class="headerlink" title="变量与数据类型："></a>变量与数据类型：</h3><p>1、变量</p><p>在Java中，变量分为两种：基本类型的变量和引用类型的变量。</p><p>在Java中，变量必须先定义后使用，在定义变量的时候，可以给它一个初始值。</p><p>变量的一个重要特点是可以重新赋值，还可以赋值给其他变量。</p><p>2、八大基本数据类型</p><ul><li>整数类型：byte、short、int、long</li><li>浮点数类型：float, double </li><li>布尔类型：boolean</li><li>字符类型: char</li></ul><p>注：String是一个类</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、Java介绍&quot;&gt;&lt;a href=&quot;#一、Java介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Java介绍&quot;&gt;&lt;/a&gt;一、Java介绍&lt;/h2&gt;&lt;p&gt;OpenJDK&lt;/p&gt;
&lt;p&gt;JVM&lt;/p&gt;
&lt;p&gt;Java优点&lt;/p&gt;
&lt;p&gt;Java缺点</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理</title>
    <link href="http://example.com/posts/8d4b7ae1.html"/>
    <id>http://example.com/posts/8d4b7ae1.html</id>
    <published>2023-09-08T08:25:04.000Z</published>
    <updated>2024-10-10T11:43:55.440Z</updated>
    
    
    
    
    <category term="计算机四大件" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
    
    <category term="计算机组成原理" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机操作系统</title>
    <link href="http://example.com/posts/dbeddcc1.html"/>
    <id>http://example.com/posts/dbeddcc1.html</id>
    <published>2023-09-08T08:24:22.000Z</published>
    <updated>2024-10-10T11:43:55.441Z</updated>
    
    
    
    
    <category term="计算机四大件" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
    
    <category term="计算机操作系统" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="http://example.com/posts/79666db.html"/>
    <id>http://example.com/posts/79666db.html</id>
    <published>2023-09-08T08:23:29.000Z</published>
    <updated>2024-10-10T11:43:55.437Z</updated>
    
    
    
    
    <category term="计算机四大件" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="http://example.com/posts/9520183a.html"/>
    <id>http://example.com/posts/9520183a.html</id>
    <published>2023-09-08T08:11:55.000Z</published>
    <updated>2023-09-08T09:08:54.144Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>ERP</title>
    <link href="http://example.com/posts/6af6f81b.html"/>
    <id>http://example.com/posts/6af6f81b.html</id>
    <published>2023-09-06T02:49:40.000Z</published>
    <updated>2023-09-08T08:13:00.309Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/posts/e255a10a.html"/>
    <id>http://example.com/posts/e255a10a.html</id>
    <published>2023-09-04T10:30:53.000Z</published>
    <updated>2023-09-08T08:16:45.458Z</updated>
    
    
    
    
    <category term="计算机四大件" scheme="http://example.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%9B%E5%A4%A7%E4%BB%B6/"/>
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>项目的需求分析与设计</title>
    <link href="http://example.com/posts/ff5802e5.html"/>
    <id>http://example.com/posts/ff5802e5.html</id>
    <published>2023-08-27T13:20:34.000Z</published>
    <updated>2023-09-08T08:13:00.314Z</updated>
    
    <content type="html"><![CDATA[<p>项目需求分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;项目需求分析&lt;/p&gt;
</summary>
      
    
    
    
    <category term="javaEE" scheme="http://example.com/categories/javaEE/"/>
    
    
    <category term="-项目报告 -需求分析" scheme="http://example.com/tags/%E9%A1%B9%E7%9B%AE%E6%8A%A5%E5%91%8A-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>javaweb</title>
    <link href="http://example.com/posts/6e827460.html"/>
    <id>http://example.com/posts/6e827460.html</id>
    <published>2023-08-26T15:16:33.000Z</published>
    <updated>2023-08-26T15:38:29.636Z</updated>
    
    
    
    
    <category term="javaEE" scheme="http://example.com/categories/javaEE/"/>
    
    
    <category term="javaweb" scheme="http://example.com/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+github 部署</title>
    <link href="http://example.com/posts/4f9fc186.html"/>
    <id>http://example.com/posts/4f9fc186.html</id>
    <published>2023-08-25T23:17:09.000Z</published>
    <updated>2024-10-10T11:38:54.165Z</updated>
    
    <content type="html"><![CDATA[<p>第一次部署一个个人博客记录一下</p><h2 id="简单过程"><a href="#简单过程" class="headerlink" title="简单过程"></a>简单过程</h2><p>过程：</p><p>1、前期准备：GitHub、Git、Node.js</p><p>2、GitHub创建新仓库命名为username.github.io</p><ul><li>注：如果自己输入地址打不开就进入到项目：settings-&gt;pages-&gt;View Site</li></ul><p>3、npm安装hexo-cli:npm install hexo-cli</p><p>4、新建文件夹Blog作为Hexo本地资源地址，在本文件夹cmd输入：hexo init</p><p>注：如果显示hexo command not found，试试npx hexo init，可能是你安装到了本地（安装到全局：npm install hexo-cli -g)</p><blockquote><p>打开_config.yml修改底部deploy，连接你的github个人网站</p><p>  deploy:<br>  type: git<br>  repository: 你的github地址<br>  branch: main</p></blockquote><p>5、发博客：hexo new post “新博客的名字”</p><ul><li>注：这里的post是Blog&#x2F;scaffolds&#x2F;里的post.md，是一种格式文件，可以修改</li></ul><p>6、每次修改博客内容都要三连：<strong>hexo c&amp;&amp;hexo g&amp;&amp;hexo d</strong></p><p>7、注意：后面要空格，包括配置文件和.md文件头的填写</p><h2 id="零散的知识"><a href="#零散的知识" class="headerlink" title="零散的知识"></a>零散的知识</h2><h3 id="layout（布局）"><a href="#layout（布局）" class="headerlink" title="layout（布局）"></a>layout（布局）</h3><p>当你每一次使用代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章名&quot;</span><br></pre></td></tr></table></figure><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><p>而new这个命令其实是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>只不过这个layout默认是post罢了。</p><h4 id="page"><a href="#page" class="headerlink" title="page"></a>page</h4><p>如果你想另起一页，那么可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page board</span><br></pre></td></tr></table></figure><p>系统会自动给你在source文件夹下创建一个board文件夹，以及board文件夹中的index.md，这样你访问的board对应的链接就是<code>http://xxx.xxx/board</code></p><h4 id="draft"><a href="#draft" class="headerlink" title="draft"></a>draft</h4><p>draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft newpage</span><br></pre></td></tr></table></figure><p>这样会在source&#x2F;_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server --draft</span><br></pre></td></tr></table></figure><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到post中，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo publish draft newpage</span><br></pre></td></tr></table></figure><p>就会自动把newpage.md发送到post中。</p><h3 id="menu（导航栏）"><a href="#menu（导航栏）" class="headerlink" title="menu（导航栏）"></a>menu（导航栏）</h3><p>如果你想要自己再自定义一个菜单栏的选项，那么就</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page yourdiy</span><br></pre></td></tr></table></figure><p>它就会在根目录下<code>source</code>文件夹中新建了一个<code>yourdiy</code>文件夹，以及index.md，在index.md中写上你想要写的东西，就可以在网站上展示出来了。然后在主题配置文件的menu菜单栏添加一个 <code>Yourdiy : /yourdiy</code>，注意冒号后面要有空格，以及前面的空格要和menu中默认的保持整齐。然后在<code>languages</code>文件夹中，找到<code>zh-CN.yml</code>，在index中添加<code>yourdiy: &#39;中文意思&#39;</code>就可以显示中文了。</p><h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><p>1、遇到github连接问题，可能会报错，试试加速器(watt)或提前连上github</p><ul><li>将Https改为Http</li><li>换个网络</li></ul><p>2、使用主题记得下插件</p><h2 id="主题和美化"><a href="#主题和美化" class="headerlink" title="主题和美化"></a>主题和美化</h2><p>hexo的主题比较丰富，使用的较多的是butterfly</p><p>1、图片：可以使用文件地址或者链接的形式，可以使用路过图床</p><p><a href="https://imgse.com/">路过图床 - 免费图片上传, 专业图片外链, 免费公共图床 (imgse.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一次部署一个个人博客记录一下&lt;/p&gt;
&lt;h2 id=&quot;简单过程&quot;&gt;&lt;a href=&quot;#简单过程&quot; class=&quot;headerlink&quot; title=&quot;简单过程&quot;&gt;&lt;/a&gt;简单过程&lt;/h2&gt;&lt;p&gt;过程：&lt;/p&gt;
&lt;p&gt;1、前期准备：GitHub、Git、Node.js&lt;/p</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://example.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
